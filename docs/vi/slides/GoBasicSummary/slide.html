<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Giới thiệu căn bản về Go (Golang)</title>

    <meta charset='utf-8'>
    <script
      src='../slides.js'></script>
  </head>
  
  <style>
    /* Your individual styles here, or just use inline styles if that’s
       what you want. */
    
    
  </style>

  <body style='display: none'>

    <section class='slides layout-regular template-default'>
      
      <!-- Your slides (<article>s) go here. Delete or comment out the
           slides below. -->
        
        
      
      <article class='biglogo'>
      </article>

      <article>
        <h1>
					Tổng quan cơ bản về Go.
        </h1>
        <p>
          Nguyễn Văn Cao Nguyên &lt;nuyen@open-vn.org&gt;
          <br>
          <a href="//www.open-vn.org/docs/vi/sildes/GoBasicSummary">www.open-vn.org/docs/vi/sildes/GoBasicSummary</a>
        </p>
      </article>
      
      <article>
      	<h2>
      		Nội dung.
      	</h2>
      	<p>
      		<ul>
      			<li>Các kiểu dữ liệu và biến số.
      			<li>Các cấu trúc điều khiển.
      			<li>Cách tổ chức một project.
      			<li>Lập trình hướng đối tượng.
      			<li>Lập trình Web căn bản.
      		</ul>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Các kiểu dữ liệu và biến số.
      	</h3>
      	<p>
      		<b>Boolean</b><br/>
      		<b>Numeric</b><br/>
      		<b>Struct</b><br/>
      		<b>Pointer</b><br/>
      		<b>Function</b><br/>
      		<b>Array</b><br/>
      		<b>Slice</b><br/>
      		<b>String</b><br/>
      		<b>Map</b><br/>
      		<b>Interface</b><br/>
      		<b>Channel</b><br/>
      		<b>Người dùng tự định nghĩa</b><br/>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Boolean
      	</h3>
      	<p>
      		<pre class="prettyprint">
var b bool = false
<span class="com">//Khai báo nhanh :=, chỉ dùng bên trong thân hàm</span>
b := false
b, c := true, false
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Numeric
      	</h3>
      	<p>
      		<ul>
		    		<li><i>uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32, float64</i><br/>
		    		<li><i>complex64, complex128</i><br/>
		    		<li><i>byte, rune</i><br/>
		    		<li><b><i>uint, int, uintptr</i></b>
      		</ul>
      	</p>
      	<p>
      		<pre class="prettyprint">
var a int
b := 10
<span class="com">//a, b có kiểu int</span>
var c int8
a = b + c <span class="com">//báo lỗi</span>
a = b + int(c)
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Struct
      	</h3>
      	<p>
      		<pre class="prettyprint">
type MyStruct struct {
&nbsp;&nbsp;I int
&nbsp;&nbsp;B bool
}
      		</pre>
      		<pre class="prettyprint">
var x MyStruct
x.I = 7
x.B = true

y := MyStruct{8, false}
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Pointer
      	</h3>
      	<p>
      		<pre class="prettyprint">
i1 := 5

p1 := new(int)
p1 = &i1

var p2 *int
p2 = p1

i2 := *p2 + 5

var p3 *MyStruct
p3.I = 4<span class="com">//báo lỗi</span>

p4 := new(MyStruct)
p4.I = 4<span class="com">//ok, note!</span>

p5 := &MyStruct{i2, true}
p5.I = 4
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Function
      	</h3>
      	<p>
      		<pre class="prettyprint">
<span class="com">//Hàm không có tham số trả về</span>
func A(x ...int) {
&nbsp;&nbsp;println(len(x))
}
A(0,0,0,0)<span class="com">//4</span>
<span class="com">//Hàm có tham số trả về</span>
func B(x int) (int, int) {
&nbsp;&nbsp;return x+1, x-1
}
x, y := B(5)<span class="com">//x = 6; y = 4</span>
z := B(7)<span class="com">//báo lỗi</span>
t,_ := B(7)<span class="com">//t = 8</span>


func C(a, b int, f func(int) (int, int)) {
&nbsp;&nbsp;x, y := f(a+b)
&nbsp;&nbsp;print("x = ", x, " y = ", y)
}
C(3,4,B)<span class="com">//x = 8 y = 6</span>
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Array
      	</h3>
      	<p>
      		Độ dài của Array được quyết định trong <i>compile time</i>
      		<pre class="prettyprint">
[32]int
[2*N] struct { x, y int32 }
[2*N]*MyStruct
[1000]*float64
[3][5]int
[2][2][2]float64  //[2]([2]([2]float64))

x := [3]int{2,1,0}
y := [...]int{3,2,1,0}
z := [...]*MyStruct{
&nbsp;&nbsp;&MyStruct{1,true},
&nbsp;&nbsp;&MyStruct{2,false},
}
					</pre>
      	</p>
      </article>
      
      <article class="smaller">
      	<h3>
      		Slice
      	</h3>
      	<p>
      		<ul>
      			<li>Tương tự như Array nhưng độ dài được quyết định trong <i>runtime</i><br/>
      			<li>Slice là kiểu reference.
      			<li>Slice sử dụng nhiều hơn Array trong Go.
      			<li>Xem thêm:
      				<a href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html">
      					http://blog.golang.org/2011/01/go-slices-usage-and-internals.html
      				</a>
      			</li>						
      		</ul>
      		<pre class="prettyprint">
var s1 []int
s1[0] = x<span class="com">//runtime error: index out of range</span>

s2 = make([]int, 4)
s2[0] = 10

s2 := []int{9, 11, 12, 13, 14}

s3 := s2[:]<span class="com">//tương đương s3 := s2</span>
s3[0] = 10<span class="com">//s2[0] = 10</span>
s4 := s2[1:3]<span class="com">//[11, 12]</span>
s5 := s2[1:]<span class="com">//[11, 12, 13, 14]</span>
s6 := s2[:3]<span class="com">//[10, 11, 12]</span>
s2 = append(s2, 15, 16)
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		String
      	</h3>
      	<p>
      		String là kiểu Slice <i>read-only</i>.
      		<pre class="prettyprint">
var s string
s = "Xâu ký tự"
s2 := `&lt;input type="text" onlic="alert('js');" /&gt;`
s3 := s[:] + s2
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Map
      	</h3>
      	<p>
      		Map tương tự như Hash Table trong C/C++, Dictionary trong C#, mảng kết hợp trong PHP
      		<pre class="prettyprint">
m := map[string]int{
&nbsp;&nbsp;"key1": 3,
&nbsp;&nbsp;"key2": 4,
}
delete(m, "key1")

m2 := make(map[string]string)
m2["key1"] = 5
val, ok := m2["key2"]<span class="com">//ok = false</span>
      		</pre>
      	</p>
      </article>
      
      <article>
      	<h3>
      		Interface.
      	</h3>
      	<p>
      		Rất giống với khái niệm Interface trong Java.<br/>
      		Mọi biến số trong Go đều thực hiện một interface{}
      		<pre class="prettyprint">
m := map[string]interface{}{
&nbsp;&nbsp;"int_val": 3,
&nbsp;&nbsp;"string_val": "abcd",
}
print(5+m["int_val"].(int))
      		</pre>
      	</p>
      	Interface sẽ được tìm hiểu kỹ hơn trong phần lập trình hướng đối tượng.
      </article>
      
    <article>
    	<h3>
    		Cấu trúc điềi khiển.
    	</h3>
    	<p>
    		<ul>
    			<li>If
    			<li>Switch
    			<li>For
    		</ul>
    	</p>
    </article>
    
    <article>
    	<h3>
    		If
    	</h3>
    	<p>
    		Cặp dấu ngoặc {} luôn bắt buộc, ngoặc () thì không.
    		<pre class="prettyprint">
if a := 5; a &lt; b {
<span class="com">  //</span>
} else {
<span class="com">  //</span>
}
    		</pre>
    	</p>
    </article>
    
    <article class="smaller">
    	<h3>
    		Switch
    	</h3>
    	<p>
    		<pre class="prettyprint">
fmt.Println("When's Saturday?")
today := time.Now().Weekday()
switch time.Saturday {
case today+0:
fmt.Println("Today.")
case today+1:
fmt.Println("Tomorrow.")
case today+2:
fmt.Println("In two days.")
default:
fmt.Println("Too far away.")
}

t := time.Now()
switch {
case t.Hour() &lt; 12:
fmt.Println("Good morning!")
case t.Hour() &lt; 17:
fmt.Println("Good afternoon.")
default:
fmt.Println("Good evening.")
}
    		</pre>
    	</p>
    </article>
    
    <article>
    	<h3>
    		For
    	</h3>
    	<p>
    		<pre class="prettyprint">
for i:=0; i&lt;10; i++ {
}

for i&lt;10 {
&nbsp;&nbsp;i++;
}

for {
}

s := []int{9, 8, 7, 6}
for i := range s {
&nbsp;&nbsp;print(i)
}
<span class="com">//0 1 2 3</span>    			
for i, v := range s {
}
    		</pre>
    	</p>
    </article>

		<article>
			<h2>
				Cách tổ chức một Go project.
			</h2>
		</article>
		
		<article>
			<h3>
				Cmd và Package.
			</h3>
			<p>
				Có thể hiểu Cmd là ứng dụng<br/>
				Còn Package là một thư viện.<br/>
				Ta thường có nhu cầu phân bổmột ứng dụng ra nhiều file hoặc nhiều package để dễ dàng quản lý, tái sử dụng,
			</p>
		</article>
		
		<article>
			<h3>
				Một ứng dụng đơn giản.
			</h3>
			<p>
				<pre class="prettyprint">
package main

import (
&nbsp;&nbsp;"fmt"
)
<span class="com">//chỉ có package main mới có hàm main</span> 
func main() {
&nbsp;&nbsp;SayHello()
}
<span class="com">//trong Go ta không cần khái niệm prototype như trong C/C++</span>
func SayHello() {
&nbsp;&nbsp;fmt.Print("Hello World!")
}
				</pre>
			</p>
		</article>
		
		<article class="smaller">
			<p>
				~/example/main.go
				<pre class="prettyprint">
package main

func main() {
&nbsp;&nbsp;SayHello()
}
				</pre>
			</p>
			<p>
				~/example/hi.go
				<pre class="prettyprint">
package main

import (
&nbsp;&nbsp;"fmt"
)

func SayHello() {
&nbsp;&nbsp;fmt.Print("Hello World!")
}
				</pre>
				<code>
				cd ~/example & go build
				</code>
			</p>
		</article>
		
		<article>
			<h3>
				Tạo một opensource project.
			</h3>
			<p>
				<ul>
					<li>Tạo một repo. Ví dụ <i>github.com/nvcnvn/demopkg</i>
					<li>Tạo một biến enviroment GOPATH có giá trị là một đường dẫn tới một thư mục trên máy.
					<li>Trong thư mục này tạo 3 folder: src, bin, pkg
					<li>Trong thư mục src tạo một hệ thống thư mục con có cấu trúc như repo đã tạo.
					<li>cd đến thư mục repo dùng lệnh <i>go install</i> để biên dịch.
					<li>Đồng bộ hóa thư mục repo với repo thật sự.
					<li>Dùng đường dẫ repo để sử dụng package. Ví dụ<i>import "github.com/nvcnvn/demopkg"</i>
				</ul>
			</p>
		</article>
		
		<article class"smaller">
			<p>
				<i>GOROOT/src/github.com/nvcnvn/demopkg/demo.go</i>
				<pre class="prettyprint">
package demopkg
import (
&nbsp;&nbsp;"fmt"
)
func init() {
&nbsp;&nbsp;fmt.Print("Package init")
}
func Foo() {
&nbsp;&nbsp;fmt.Print("Foo")
}
func bar() {
&nbsp;&nbsp;fmt.Print("bar")
}
type DemoStruct struct {
&nbsp;&nbsp;I int
&nbsp;&nbsp;B bool
&nbsp;&nbsp;s string
}		
				</pre>
			</p>
			<p>
		</article>
		
		<article>
				~/example/main.go
				<pre class="prettyprint">
package main
import (
&nbsp;&nbsp;demo "github.com/nvcnvn/demopkg"
)
func main() {
&nbsp;&nbsp;demo.Foo()
<span class="com">//output: Package init</span>
<span class="com">//output: Foo</span>
&nbsp;&nbsp;demo.bar()
<span class="com">//báo lỗi</span>
}
				</pre>
			</p>
		</article>
		
		<article>
			<h2>
				Lập trình Hướng đối tượng với Go.
			</h2>
		</article>
		<article>
			<h1>
				Go có phong cách lập trình hướng đối tượng rất riêng.
			</h1>
			<p>
				<ul>
					<li>Hỗ trợ method, mọi kiểu dữ liệu đều có thể co method.
					<li>Không hỗ trợ kế thừa (theo nghĩa các ngôn ngữ khác).
					<li>Hỗ trợ mãnh mẽ cho interface.
				</ul>
			</p>
		</article>
		
		<article>
			<h3>
				Method.
			</h3>
			<p>
				Không thể thêm method cho các dữ liệu cơ bản cũng như các kiểu dữ liệu 
				dến từ các pkg khác. Nhưng:
				<pre class="prettyprint">
type Int int

func (i Int) Pow() Int {
&nbsp;&nbsp;return i*i
}

type MyDemo demopkg.MyStrutc

func (m *MyDemo) Foo() int {
&nbsp;&nbsp;return m.I
}

func (m *MyDemo) Bar() string {
&nbsp;&nbsp;return m.s<span class="com">//báo lỗi</span>
}
				</pre>
			</p>
		</article>
		<article>
			<h3>
				Pointer receiver
			</h3>
			<pre class="prettyprint">
type MyStruct struct {
	I int
	B bool
	s string
}
func (m *MyStruct) Foo(i int) {
&nbsp;&nbsp;m.I=i
}
func (m MyStruct) Bar(i int) {
&nbsp;&nbsp;m.I=i
}
			</pre>
			<pre class="prettyprint">
m := MyStruct{}
m.Foo(4)<span class="com">//4</span>
fmt.Println(m.I)
m.Bar(5)<span class="com">//4</span>
fmt.Println(m.I)
		</pre>
		</article>
		
		<article>
			<h3>
				"Kế thừa"
			</h3>
			<pre class="prettyprint">
type A struct {
&nbsp;&nbsp;X int
}
type B strutc {
&nbsp;&nbsp;A
&nbsp;&nbsp;Y int
}
func Test(a A) {
&nbsp;&nbsp;fmt.Println(a.X)
}
			</pre>
			<pre class="prettyprint">
b := B{}
b.Y = 3
b.X = 5<span class="com">//ok</span>
Test(b)<span class="com">//báo lỗi</span>
			</pre>
		</article>
		<article>
			<h3>
				Interface
			</h3>
			<pre class="prettyprint">
func (a *A) Sing() int {
&nbsp;&nbsp;return a.X
}
func (a A) Kill() int {
&nbsp;&nbsp;return a.X+10
}
type Singer interface {
&nbsp;&nbsp;Sing() int
}
type Killer interface {
&nbsp;&nbsp;Kill() int
}
func TestSinger(s Singer) {
&nbsp;&nbsp;fmt.Println(s.Sing())
}
func TestKiller(k Killer) {
&nbsp;&nbsp;fmt.Println(k.Kill())
}
			</pre>
		</article>
		<article>
			<pre class="prettyprint">
a1 := A{}
a2 := &A{}

TestSinger(a1)<span class="com">//báo lỗi</span>
TestSinger(a2)<span class="com">//ok</span>

TestKiller(a1)<span class="com">//ok</span>
TestKiller(a2)<span class="com">//ok</span>

type C strutc {
&nbsp;&nbsp;A
&nbsp;&nbsp;Z int
}

c := C{}
TestSinger(c)<span class="com">//báo lỗi</span>
TestSinger(&c)<span class="com">//ok</span>
TestKiller(c)<span class="com">//ok</span>

			</pre>
		</article>
		<article>
			<h2>
				Lập trình Web căn bản
			</h2>
		</article>
		<article class="smaller">
			<h3>
				package "net/http"
			</h3>
			<pre class="prettyprint">
package main

import (
&nbsp;&nbsp;"fmt"
&nbsp;&nbsp;"net/http"
)

type Index struct{}

func (i Index) ServeHTTP(w http.ResponseWriter, r *http.Request) {
&nbsp;&nbsp;fmt.Fprint(w, "Hello!")
}

type Info struct{}

func (i Info) ServeHTTP(w http.ResponseWriter, r *http.Request) {
&nbsp;&nbsp;fmt.Fprint(w, "This is a Go web server.")
}

func main() {
&nbsp;&nbsp;var idx Index
&nbsp;&nbsp;http.Handle("/", idx)

&nbsp;&nbsp;var inf Info
&nbsp;&nbsp;http.Handle("/info", inf)

&nbsp;&nbsp;http.ListenAndServe("localhost:8080", nil)
}
			</pre>
		</article>
    </section>
  </body>
</html>
